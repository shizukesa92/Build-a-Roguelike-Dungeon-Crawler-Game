createMap = (width = 100, height = 100, maxRoomSize = 20, minRoomSize = 6, maxHallLength = 5, numRooms = 20, roomChance = .75) => {

	// Initializes grid
	let map = Array(width).fill(0);
	const blankCol = Array(height).fill(0);
	map = map.map(() => blankCol);

	// Fills map with a square grid room from defined x1,y1 to x2,y2
	fillRect = (map, startCoord, endCoord, fillVal) => {
		for (let i = startCoord.x; i < startCoord.x + endCoord.x; i++) {
			map[i].fill(fillVal, startCoord.y, endCoord.y + startCoord.y);
		}
		return map;
	}

	fillRect(map, {
		x: 45,
		y: 45
	}, {
		x: 10,
		y: 10
	}, 1);

	// Takes a map matrix and a coordinate object
	// Returns false if not a wall, otherwise the direction of the open tile
	isWall = (map, coords) => {
		// return false if tile isn't wall
		if (map[coords.x][coords.y] !== 0) {
			return false;
		}
		// left is open
		if (typeof map[coords.x - 1] !== 'undefined' && map[coords.x - 1][coords.y] == 1) {
			return 'left';
		}
		// right is open
		if (typeof map[coords.x + 1] !== 'undefined' && map[coords.x + 1][coords.y] == 1) {
			return 'right';
		}
		// top is open
		if (map[coords.x][coords.y - 1] == 1) {
			return 'top';
		}
		// bottom is open
		if (map[coords.x][coords.y + 1] == 1) {
			return 'bottom';
		}

		return false;
	}

	// Loops until it finds a wall tile
	findWall = (map) => {
		const coords = {
			x: 0,
			y: 0
		};
		let wallDir = false;
		while (!wallDir) {
			coords.x = Math.floor(Math.random() * map.length);
			coords.y = Math.floor(Math.random() * map[0].length);
			wallDir = isWall(map, coords);
		}
		return {
			coords: coords,
			openDir: wallDir
		};
	}

	// Will keep trying to place random rooms in random places until it succeeds.
	placeRoom = (map) => {
		let wall, width, height, isRoom, startX, startY, coords, numClear;
		while (true) {
			// Create random location and room
			numClear = 0;
			wall = findWall(map);
			coords = wall.coords;
			width = Math.floor((Math.random() * (maxRoomSize - minRoomSize)) + minRoomSize);
			height = Math.floor((Math.random() * (maxRoomSize - minRoomSize)) + minRoomSize);
			switch (wall.openDir) {
				case 'right':
					startX = coords.x - width;
					startY = (coords.y - Math.floor(height / 2)) + getDoorOffset(height);
					break;
				case 'left':
					startX = coords.x + 1;
					startY = (coords.y - Math.floor(height / 2)) + getDoorOffset(height);
					break;
				case 'top':
					startX = (coords.x - Math.floor(width / 2)) + getDoorOffset(width);
					startY = coords.y + 1;
					break;
				case 'bottom':
					startX = (coords.x - Math.floor(width / 2)) + getDoorOffset(width);
					startY = coords.y - height;
					break;
				default:
					break;
			}
			// Exit if room would be outside matrix
			if (startX < 0 || startY < 0 || startX + width >= map.length || startY + height >= map[0].length) {
				continue;
			}
			// check if all spaces are clear
			for (let i = startX; i < startX + width; i++) {
				if (map[i].slice(startY, startY + height).every(tile => tile === tileType.WALL)) {
					numClear++;
				}
			}
			if (numClear === width) {
				fillRect(map, {
					x: startX,
					y: startY
				}, {
					x: width,
					y: height
				}, tileType.FLOOR);
				map[coords.x][coords.y] = 1;
				return map;
			}
		}

		getDoorOffset = (length) => {
			return Math.floor((Math.random() * length) - Math.floor((length - 1) / 2));
		}
	}


	// create rooms
	for (let x = 0; x < numRooms; x++) {
		placeRoom(map);
	}

	return map;
}
