const generate = () => {
	// Generates a random array of length equals to grid height  
	const height = 100,
		width = 100;
	let map = [];

	for (let y = 0; y < height; y++) {
		map.push([]);
		for (let x = 0; x < width; x++) {
			map[y].push({
				type: 0,
			});
		}
	}

	// Generates seed of a random height between min and max room heights, and of a starting x,y that does not exceed max height and width (with an offset to prevent room from hitting wall

	const seed = {
		xcoords: 1 + Math.floor(Math.random() * 75),
		ycoords: 1 + Math.floor(Math.random() * 75),
		rheight: 10 + Math.floor(Math.random() * 10),
		rwidth: 10 + Math.floor(Math.random() * 10)
	};

	// Places seed in map
	const place = (map, {
		xcoords,
		ycoords,
		rwidth,
		rheight,
		id
	}) => {
		for (let i = ycoords; i < ycoords + rheight; i++) {
			for (let j = xcoords; j < xcoords + rwidth; j++) {
				map[i][j] = {
					type: 1,
					id
				};
			}
		}
		return map;
	};
	map = place(map, seed);

	const grow = (map, {
		xcoords,
		ycoords,
		rwidth,
		rheight
	}) => {

		// Attempts to place rooms in given direction
		const rooms = [];

		const north = {
			height: 10 + Math.floor(Math.random() * 10),
			width: 10 + Math.floor(Math.random() * 10),
			xcoords: xcoords + Math.floor(Math.random() * rwidth - 1),
			ycoords: ycoords + north.height + 1,
			xdoor: north.x + Math.floor(Math.random * Math.min(xcoords + rwidth, north.xcoords + north.rwidth) - 1),
			ydoor: north.ycoords - 1
		};

		rooms.push(north);

		const south = {
			rheight: 10 + Math.floor(Math.random() * 10),
			rwidth: 10 + Math.floor(Math.random() * 10),
			xcoords: xcoords + Math.floor(Math.random() * rwidth - 1),
			ycoords: ycoords - south.height - 1,
			xdoor: south.x + Math.floor(Math.random * Math.min(xcoords + rwidth, south.xcoords + south.rwidth) - 1),
			ydoor: ycoords - 1
		};

		rooms.push(south);

		const east = {
			rheight: 10 + Math.floor(Math.random() * 10),
			rwidth: 10 + Math.floor(Math.random() * 10),
			xcoords: xcoords + rwidth + 1,
			ycoords: ycoords + Math.floor(Math.random * rheight - 1),
			xdoor: east.xcoords - 1,
			ydoor: east.ycoords + Math.floor(Math.random * Math.min(east.ycoords + east.rheight, ycoords + rheight) - 1)
		};

		rooms.push(east);

		const west = {
			rheight: 10 + Math.floor(Math.random() * 10),
			rwidth: 10 + Math.floor(Math.random() * 10),
			xcoords: xcoords - rwidth - 1,
			ycoords: ycoords + Math.floor(Math.random * rheight - 1),
			xdoor: xcoords - 1,
			ydoor: west.ycoords + Math.floor(Math.random * Math.min(west.ycoords + west.rheight, ycoords + rheight) - 1)
		};

		rooms.push(west);

		const placed = [];
		rooms.forEach(room => {
			if (valid(map, room)) {
				map = grow(map, room);
				map = place(map, {
					xcoords: room.xdoor,
					ycoords: room.ydoor
				});
				// need placed room values for the next seeds
				placed.push(room);
			}
		});
		return {
			map,
			placed
		};
	};

	// Validifies map placement
	const valid = (map, {
		xcoords,
		ycoords,
		rwidth,
		rheight
	}) => {
		// Checks if room exceeds map parameters
		if (ycoords < 1 || ycoords + rheight > map.length - 1) {
			return false;
		}
		if (xcoords < 1 || xcoords + rwidth > map[0].length - 1) {
			return false;
		}

		// Checks for room collision
		for (let i = ycoords - 1; i < ycoords + height + 1; i++) {
			for (let j = xcoords - 1; j < xcoords + rwidth + 1; j++) {
				if (grid[i][j].type == 1) {
					return false;
				}
			}
		}
		return true;
	};

	// Fills map recursively
	const fill = (map, rooms, count) => {
		if (count + 1 > 5 || !rooms.length) {
			return map;
		}

		map = grow(map, rooms.pop());
		rooms.push(...map.placed);
		count += map.placed.length;
		return fill(map.map, rooms, count);
	};
	return fill(map, seed);



};
